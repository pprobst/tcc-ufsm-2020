\begin{table}[]
\resizebox{\textwidth}{!}{%
\begin{tabular}{llllllll}
Algoritmo & Método de geração & Entrada & Saída & Controlabilidade & Conectividade & Complexidade & Desempenho \\
Random Walker & Construtivo & Mapa preenchido & \textit{Top-down cavern-like} & Baixa & Sim/Não & Baixa & TODO \\
Cellular Automata & Construtivo & Mapa caótico & \textit{Top-down cavern-like} & Média & Não & Baixa & TODO \\
BSP Dungeon & Construtivo & Mapa preenchido & \textit{Top-down mansion-like} & Média & Sim & Média & TODO \\
Digger & Construtivo & Mapa preenchido & \textit{Top-down mansion-like} & Baixa & Sim & Média & TODO \\
WFC & Baseado em busca & Estrutura qualquer & Localmente similar à entrada & Baixa & Não & Alta & TODO
\end{tabular}%
}
\end{table}

Seguindo a taxonomia definida por Togelius et al. todos os algoritmos da tabela geram conteúdo automático, genérico e estocástico, em tempo de geração offline, 
controlados a partir de parâmetros.

TODO: 
* Descrever como cada algoritmo funciona. 
* Fazer pseudocódigo simplificado. 
* Mostrar desempenho.

-- Random Walker
O algoritmo Random Walker para geração de dungeons utiliza agentes que "cavam" o mapa preenchido, gerando uma caverna (quando os agentes são inicializados na mesma posição) ou
um sistema de cavernas (quando os agentes são inicializados em posições diferentes). O tempo de vida de cada agente e a direção seguida a cada passo do mesmo são determinados
estocasticamente, e a quantidade de agentes é incrementada a cada iteração do algoritmo, o que depende da quantidade (%) de tiles de chão desejadas.
No modo do algoritmo para a geração de um sistema de cavernas, a conectividade não é assegurada; isso pode ser contornado posteriormente a partir de um algoritmo
baseado em flood fill para a seleção das regiões desconectadas do mapa, para então conectá-las a partir das bordas.

-- Cellular Automata
O algoritmo Cellular Automata (CA) para geração de dungeons funciona tendo como base um mapa caótico (tipicamente entre 40% e 50% de tiles de chão) como entrada.
A partir de regras definidas pelo usuário, o mapa é alterado em n iterações; quanto maior o número de iterações, maior será a suavização sofrida no mapa. Um exemplo
de regra executada a cada iteração do algoritmo é a seguinte:

vizinhos_paredes = conte_tiles_vizinhos(parede)
se vizinhos_paredes >= 5 {
    mapa[tile_atual] = parede
}
senão {
    mapa[tile_atual] = chão
}

Os tiles vizinhos a serem considerados podem seguir tanto a vizinhança de Moore (vizinhos ortogonais e diagonais) quanto a vizinhança de von Neumann (apenas vizinhos ortogonais).
A partir da definição das regras, é possível gerar as mais varidas dungeons (ver imagem), não apenas cavernas.
O algoritmo de CA não assegura conectividade de regiões geradas em seu modelo tradicional; para contornar esse problema, pode ser utilizado o mesmo algoritmo citado na seção anterior.
Após realizar a conexão entre as regiões desconectadas, é comum que os túneis não pareçam orgânicos. Podemos resolver isso com uma simples iteração extra de um proto-CA, utilizando
regras mais específicas; entretanto, isso pode não ser desejado caso a intenção seja exibir uma suposta interferência humana no sistema de cavernas.

Como o algoritmo Random Walker pode gerar mapas caóticos (mas controlados), ele pode servir como entrada para o algoritmo de CA, o que gera resultados mais interessantes se comparados
com mapas descontroladamente caóticos (ver imagem).

-- Binary Space Partitioning (BSP) Dungeons
O algoritmo BSP Dungeon baseia-se na subdivisão do espaço e posterior adição de salas nos espaços gerados, tendo como base de funcionamento uma árvore BSP.
* aqui eu demonstro como o algoritmo funciona visualmente *
Após a inserção das salas (tipicamente retângulos), o vetor de salas pode ser reordenado a partir da posição, tamanho, entre outros atributos. As conexões entre as salas são
feitas a partir do vetor, sequencialmente -- logo, a ordem das salas no vetor regirá de que forma as salas serão conectados, alterando o resultado final.

O clássico roguelike Nethack utiliza extensivamente este algoritmo para a geração de suas dungeons TDML.

-- Digger
Além do algoritmo BSP Dungeons, o Digger é outro algorimo utilizado para a geração de mapas TDML. Neste algoritmo, as salas geradas são derivadas a partir de uma sala localizado
na região central do mapa. A cada iteração é escolhido um índice de borda aleatório da sala sendo analisada, e a partir deste índice é gerado outra sala na mesma direção da borda
escolhida, a uma distância determinada estocasticamente. Após isso, as duas salas são conectadas por uma "sala estreita", definindo um corredor.
O algoritmo termina quando o número máximo de iterações foi atingido, o que potencialmente indica a impossiblidade de inserir salas do tamanho requisitado.

Uma vantagem compartilhada entre os algoritmos BSP Dungeon e Digger reside no fato de que é possível acessar facilmente os vetores de salas/corredores posteriormente, com o intuito
de inserir itens ou inimigos depenendo dos atributos de cada sala.

-- WFC
O WaveFunctionCollapse (WFC) foi o único algoritmo baseado em busca escolhido para comparação, por conta de seus aspectos inovadores e crescente uso na indústria. Originalmente
feito para trabalhar com pixels em imagens, ele foi adaptado neste trabalho para aceitar um conjunto de caracteres ASCII.
Especificamente, o WFC é um solver -- cada célula de tamanho fixo no mapa inicialmente tem a possibilidade de aceitar todos os padrões de tiles gerados na entrada,
e a partir das regras de adjacência (baseado em similaridade no modelo Overlapping) o conjunto de padrões é reduzido até a célula ser "colapsada", ou seja, ter apenas
um padrão possível. As mudanças são propagadas da célula atual sendo analisada para as células vizinhas, que também têm seus conjuntos de possibilidades reduzidos.
O algoritmo termina quando todas as células do mapa são colapsadas; caso isso não ocorrer, chegamos a uma contradição -- neste caso, o algoritmo pode recomeçar ou retroceder
a partir de backtracking, dependendo da implementação.

O WFC é altamente dependente da estrutura de entrada. Desse modo, a qualidade do mapa gerado depende, em suma, da entrada utilizada.
Brian B. Bucklew identificou X problemas com o WFC -- e todos os problemas foram prontamente identificados neste trabalho.
* aqui eu falo de cada problema e o que fazer para tentar contorná-los *
* também cito outros modelos de WFC implementados *
